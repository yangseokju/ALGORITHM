# 백준 알고리즘 문제
### 2108_통계학

문제 : 분수 A/B는 분자가 A, 분모가 B인 분수를 의미한다. A와 B는 모두 자연수라고 하자.

두 분수의 합 또한 분수로 표현할 수 있다. 두 분수가 주어졌을 때, 그 합을 기약분수의 형태로 구하는 프로그램을 작성하시오. 기약분수란 더 이상 약분되지 않는 분수를 의미한다.

입력 : 첫째 줄과 둘째 줄에, 각 분수의 분자와 분모를 뜻하는 두 개의 자연수가 순서대로 주어진다. 입력되는 네 자연수는 모두 30,000 이하이다.

*내 제출*
```python
# 유클리드 호재법으로 최대공약수를 구한다.
def gcd(x,y):
    while y:
        x, y = y, x%y
    return x


a, b = map(int, input().split())
c, d = map(int, input().split())

ans1 = a*d+b*c # 분자
ans2 = b*d # 분모

# 최대공약수가 1이 아니면
if gcd(ans1, ans2) != 1:
    print(f'{ans1//gcd(ans1, ans2)} {ans2//gcd(ans1, ans2)}')
# 최대공약수가 1이면
else:
    print(f'{ans1} {ans2}')
```

---

### 2630_색종이 만들기

문제 : 전체 종이의 크기가 N×N(N=2k, k는 1 이상 7 이하의 자연수) 이라면 종이를 자르는 규칙은 다음과 같다.

전체 종이가 모두 같은 색으로 칠해져 있지 않으면 가로와 세로로 중간 부분을 잘라서 <그림 2>의 I, II, III, IV와 같이 똑같은 크기의 네 개의 N/2 × N/2색종이로 나눈다. 나누어진 종이 I, II, III, IV 각각에 대해서도 앞에서와 마찬가지로 모두 같은 색으로 칠해져 있지 않으면 같은 방법으로 똑같은 크기의 네 개의 색종이로 나눈다. 이와 같은 과정을 잘라진 종이가 모두 하얀색 또는 모두 파란색으로 칠해져 있거나, 하나의 정사각형 칸이 되어 더 이상 자를 수 없을 때까지 반복한다.

입력 : 첫째 줄에는 전체 종이의 한 변의 길이 N이 주어져 있다. N은 2, 4, 8, 16, 32, 64, 128 중 하나이다. 색종이의 각 가로줄의 정사각형칸들의 색이 윗줄부터 차례로 둘째 줄부터 마지막 줄까지 주어진다. 하얀색으로 칠해진 칸은 0, 파란색으로 칠해진 칸은 1로 주어지며, 각 숫자 사이에는 빈칸이 하나씩 있다.

*내 제출*
```python
def cal(x, y, n):
    # n이 0이 됐을때 return(더이상 접을수가 없는 경우)
    if n == 0:
        return
    # 첫번째 부분의 색을 color로 지정
    color = arr[x][y]
    for i in range(x, x+n):
        for j in range(y, y+n):
            # 만약 시작점의 색과 다르다면(정사각형이 모두 같은색이 아니라면)
            if color != arr[i][j]:
                # 색종이를 정사각형인 반으로 접는 경우들
                cal(x, y, n//2)
                cal(x, y+n//2, n//2)
                cal(x+n//2, y, n//2)
                cal(x+n//2, y+n//2, n//2)
                return
    # 색이 모두 같아 return이 되지 않았다면 첫번째 color를 result에 넣어준다
    result.append(color)


n = int(input())
arr = [list(map(int, input().split())) for _ in range(n)]

result = [] # 색종이의 색을 담아줄 리스트
cal(0, 0, n)
print(result.count(0))
print(result.count(1))
```