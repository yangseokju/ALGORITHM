# 백준 알고리즘 문제
### 2108_통계학

문제 : 수를 처리하는 것은 통계학에서 상당히 중요한 일이다. 통계학에서 N개의 수를 대표하는 기본 통계값에는 다음과 같은 것들이 있다. 단, N은 홀수라고 가정하자.

산술평균 : N개의 수들의 합을 N으로 나눈 값
중앙값 : N개의 수들을 증가하는 순서로 나열했을 경우 그 중앙에 위치하는 값
최빈값 : N개의 수들 중 가장 많이 나타나는 값
범위 : N개의 수들 중 최댓값과 최솟값의 차이
N개의 수가 주어졌을 때, 네 가지 기본 통계값을 구하는 프로그램을 작성하시오.

입력 : 첫째 줄에 수의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 단, N은 홀수이다. 그 다음 N개의 줄에는 정수들이 주어진다. 입력되는 정수의 절댓값은 4,000을 넘지 않는다.

*내 제출*
```python
import sys

n = int(sys.stdin.readline())
s = [0]*n
sum_k = 0
num_dict = {}

for i in range(n):
    k = int(sys.stdin.readline())
    sum_k += k # 합을 미리 구해주기
    s[i] = k
    # num_dict라는 딕셔너리를 생성해서 k가 있으면 1 추가 없으면 key값 생성
    if num_dict.get(k):
        num_dict[k] += 1
    else:
        num_dict[k] = 1

s.sort()

# 소수점 첫번째 자리에서 반올림 후 정수부분만 나타내주기
print(int(round(sum_k/n,0))) # 산술평균
# 오름차순 정렬 후 가운데값
print(s[n//2]) # 중앙값

# 최빈수가 같을때는 두번째로 작은값을 출력해야하므로
max_i, max_v = 0, 0
s1 = []
for i in num_dict.items():
    # 최대값이 나타나면 s1리스트에 그 수만 담아주기(1개일때)
    if i[1] > max_v:
        s1 = [i[0]]
        max_v = i[1]
        max_i = i[0]
    # 같은값이 있다면 값을 하나 더 추가해주기(최빈수가 여러개일때)
    elif i[1] == max_v:
        s1.append(i[0])
# 최빈수가 하나라면 첫번째 인덱스값 출력
if len(s1) == 1:
    print(s1[0])
# 2개 이상이라면 오름차순 정렬 후 두번째로 작은값 출력
else:
    s1.sort()
    print(s1[1])

# s리스트를 오름차순 정렬 했으므로 마지막값 - 첫번째값
print(s[-1]-s[0]) # 범위(최대 - 최소)
```
