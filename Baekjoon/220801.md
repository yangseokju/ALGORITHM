# 백준 알고르즘 문제
### 1009번_분산처리

문제 : 재용이는 최신 컴퓨터 10대를 가지고 있다. 어느 날 재용이는 많은 데이터를 처리해야 될 일이 생겨서 각 컴퓨터에 1번부터 10번까지의 번호를 부여하고, 10대의 컴퓨터가 다음과 같은 방법으로 데이터들을 처리하기로 하였다.

1번 데이터는 1번 컴퓨터, 2번 데이터는 2번 컴퓨터, 3번 데이터는 3번 컴퓨터, ... ,

10번 데이터는 10번 컴퓨터, 11번 데이터는 1번 컴퓨터, 12번 데이터는 2번 컴퓨터, ...

총 데이터의 개수는 항상 ab개의 형태로 주어진다. 재용이는 문득 마지막 데이터가 처리될 컴퓨터의 번호가 궁금해졌다. 이를 수행해주는 프로그램을 작성하라.

입력 : 입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 정수 a와 b가 주어진다. (1 ≤ a < 100, 1 ≤ b < 1,000,000)

출력 : 각 테스트 케이스에 대해 마지막 데이터가 처리되는 컴퓨터의 번호를 출력한다.

*내 제출*
```python
T = int(input())

for i in range(T):
    a,b=map(int,input().split())
    if a%10 == 1 or a%10 == 5 or a%10 == 6: # 곱해도 10으로 나눈 나머지가 같은 수 
        print(a%10)
    elif a%10 == 2 or a%10 == 3 or a%10 == 7 or a%10 == 8: 
        # 10으로 나눈 나머지가 4번돌면 같은 수
        if b % 4 == 0:
            print(int(str(a**4)[-1:]))
        elif b % 4 == 1:
            print(a%10)
        elif b % 4 == 2:
            print(int(str(a**2)[-1:]))
        elif b % 4 == 3:
            print(int(str(a**3)[-1:]))
    elif a%10 == 4 or a%10 == 9:
        # 10으로 나눈 나머지가 2번돌면 같은 수
        if b % 2 == 0:
            print(int(str(a**2)[-1:]))
        elif b % 2 == 1:
            print(a%10)
    elif a%10 == 0: # 끝자리가 0이면 10으로 고정
        print(10)
```
* 문제를 보고 10으로 나눈 나머지인것은 알았는데 for문으로 수를 받아서 **(제곱)을 쓰려다가 시간초과가 나고, 1부터 하나하나씩 쓰기에는 코드가 너무 길어질것 같아서 생각하다가 숫자들이 몇번 곱하면 다시 자기자신으로 돌아온다는것을 생각했다. 푸는방법을 생각하는건 어렵지 않은 문제였는데 어떻게 최대한 간결하게 표현할지 고민했던 문제였다.

---

### 1598번_꼬리를 무는 숫자 나열

문제 : 일단 4줄짜리 표에 왼쪽부터 수를 아래로 1부터 순서대로 적어나간다. 

숫자판에서 두 개의 자연수 사이의 직각거리를 구하면 된다. 여기서 직각거리는 동서방향거리와 남북방향거리의 합을 뜻한다.

예를 들어 저 숫자판에서 11과 33을 생각했다고 하자. 그렇다면 11과 33사이의 직각거리는 8이 된다.(동서방향거리 : 6, 남북방향거리 : 2) 다음 그림에 잘 나타나있다.

입력 : 두 개의 자연수가 주어진다. 각 수는 10,000,000 이하이다.

출력 : 두 개의 자연수 사이의 직각거리를 출력한다.

*내 제출*
```python
a,b = map(int,input().split())
x = (a-1)//4 # 숫자판에서 열은 입력받은 변수-1을 4로 나눈 몫으로 묶을수있다.
y = (b-1)//4 
n = (a-1)%4 # 숫자판에서 행은 입력받은 변수-1을 4로 나눈 나머지로 묶을수있다.
m = (b-1)%4 
result1,result2 = 0,0

# 숫자판에서 y의 길이(상하길이) 구하기
if x>y:
    result1 = x-y
elif x<y:
    result1 = y-x
else:
    result1 = 0

# 숫자판에서 x의 길이(좌우길이) 구하기
if n>m:
    result2 = n-m
elif n<m:
    result2 = m-n
else:
    result2 = 0
    
print(result1+result2)
```
* 뭔가 행렬은 아닐것같아서 문제를 계속 읽어보다가 4로 나눈 몫과 나머지와 연관이 있다는걸 알았다. 처음에 입력받은 변수에서 1을 안빼고 문제를 풀었는데 0 3 2 1 이런식으로 숫자가 순차적으로 깔끔하게 안나와서 코드가 너무 길어지길래 아닌것 같아서 다시 다 지우고 생각하다가 변수에서 -1을 빼고 계산해서 3 2 1 0 이런식으로 깔끔하게 나왔다. 처음에 푸는방법은 빠르게 찾았다고 생각하는데 다른데에서 조금 헤맸다.