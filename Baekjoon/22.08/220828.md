# 백준 알고르즘 문제
### 13300번_방 배정

문제 : 정보 초등학교에서는 단체로 2박 3일 수학여행을 가기로 했다. 여러 학년이 같은 장소로 수학여행을 가려고 하는데 1학년부터 6학년까지 학생들이 묵을 방을 배정해야 한다. 남학생은 남학생끼리, 여학생은 여학생끼리 방을 배정해야 한다. 또한 한 방에는 같은 학년의 학생들을 배정해야 한다. 물론 한 방에 한 명만 배정하는 것도 가능하다.

한 방에 배정할 수 있는 최대 인원 수 K가 주어졌을 때, 조건에 맞게 모든 학생을 배정하기 위해 필요한 방의 최소 개수를 구하는 프로그램을 작성하시오.

예를 들어, 수학여행을 가는 학생이 다음과 같고 K = 2일 때 12개의 방이 필요하다. 왜냐하면 3학년 남학생을 배정하기 위해 방 두 개가 필요하고 4학년 여학생에는 방을 배정하지 않아도 되기 때문이다.

입력 : 표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 수학여행에 참가하는 학생 수를 나타내는 정수 N(1 ≤ N ≤ 1,000)과 한 방에 배정할 수 있는 최대 인원 수 K(1 < K ≤ 1,000)가 공백으로 분리되어 주어진다. 다음 N 개의 각 줄에는 학생의 성별 S와 학년 Y(1 ≤ Y ≤ 6)가 공백으로 분리되어 주어진다. 성별 S는 0, 1중 하나로서 여학생인 경우에 0, 남학생인 경우에 1로 나타낸다.

출력 : 표준 출력으로 학생들을 모두 배정하기 위해 필요한 최소한의 방의 수를 출력한다.

*내 제출*
```python
n, k = map(int,input().split())
# 남학생일때와 여학생일때 학년수를 받을 리스트를 생성 1~6학년 까지이므로 크기는 7
man = [0] * 7
woman = [0] * 7

# 반복문을돌며 s가 1이면 man[y] 여학생이면 woman[y]에 1 증가
for i in range(n):
    s, y = map(int, input().split())
    if s == 1:
        man[y] += 1
    else:
        woman[y] += 1

# 리스트값에 (k-1)을 더하고 k로 나눠주면서 필요한 방의 갯수를 구한다.
# k-1을 더해주면서 방 안에 k보다 작은값이 있더라도 1이 count된다.
result = 0
for i in range(1, 7):
    result += (man[i]+(k-1))//k
    result += (woman[i]+(k-1))//k
print(result)
```
---

### 2309번_일곱 난쟁이

문제 : 왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다. 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다.

아홉 명의 난쟁이는 모두 자신이 "백설 공주와 일곱 난쟁이"의 주인공이라고 주장했다. 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다.

아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오.

입력 : 아홉 개의 줄에 걸쳐 난쟁이들의 키가 주어진다. 주어지는 키는 100을 넘지 않는 자연수이며, 아홉 난쟁이의 키는 모두 다르며, 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다.

출력 : 일곱 난쟁이의 키를 오름차순으로 출력한다. 일곱 난쟁이를 찾을 수 없는 경우는 없다.

*내 제출*
```python
num_list = [0] * 9
for i in range(9):
    num_list[i] = int(input()) # 9명의 난쟁이들을 num_list에 담는다

# num_list를 오름차순 정렬
for i in range(8):
    for j in range(i+1,9):
        if num_list[i] > num_list[j]:
            num_list[i], num_list[j] = num_list[j], num_list[i]

sum_num = 0
for k in num_list:
    sum_num += k

a = sum_num - 100 # 전체숫자에서 구할값인 100을 뺀값을 변수 a에 저장

# 리스트에서 두개씩 인덱스씩 차례로 확인하면서 두개의 값을 뺀값이 100이될때 그 두개의 인덱스에 0 대입
for i in range(8):
    for j in range(i+1,9):
        if num_list[i] + num_list[j] == a:
            num_list[i] = 0
            num_list[j] = 0
            a = -1

# 리스트를 돌면서 0이 아니면 출력
for n in range(9):
    if num_list[n] != 0:
        print(num_list[n])
```

---

### 2669번_직사각형 네개의 합집합의 면적 구하기

문제 : 평면에 네 개의 직사각형이 놓여 있는데 그 밑변은 모두 가로축에 평행하다. 이 네 개의 직사각형들은 서로 떨어져 있을 수도 있고, 겹쳐 있을 수도 있고, 하나가 다른 하나를 포함할 수도 있으며, 변이나 꼭짓점이 겹칠 수도 있다.

이 직사각형들이 차지하는 면적을 구하는 프로그램을 작성하시오.

입력 : 입력은 네 줄이며, 각 줄은 직사각형의 위치를 나타내는 네 개의 정수로 주어진다. 첫 번째와 두 번째의 정수는 사각형의 왼쪽 아래 꼭짓점의 x좌표, y좌표이고 세 번째와 네 번째의 정수는 사각형의 오른쪽 위 꼭짓점의 x좌표, y좌표이다. 모든 x좌표와 y좌표는 1이상이고 100이하인 정수이다.

출력 : 첫 줄에 네개의 직사각형이 차지하는 면적을 출력한다.

*내 제출*
```python
n = 4
result = 0
arr = [[0]*101 for _ in range(101)] 
# 1부터 100까지의 자연수가 x, y 좌표이기 때문에 0이 들어있고 크기가 101인 2차원 배열을 생성해준다
 
for i in range(4):
    # 4개의 수를 받고 포함되는 영역에 1씩 증가
    a, b, c, d = map(int, input().split())
    for v in range(a,c):
        for w in range(b,d):
            arr[v][w] += 1

# 겹치는 부분도 있기때문에 0이 아닌 영역이 있으면 결과에 1을 추가
for i in range(101):
    for j in range(101):
        if arr[i][j] != 0:
            result += 1
print(result)
```

---

### 14696번_딱지놀이

문제 : 두 어린이 A, B가 딱지놀이를 한다. 딱지놀이 규칙은 다음과 같다. 두 어린이는 처음에 여러 장의 딱지를 가지고 있고, 매 라운드마다 각자 자신이 가진 딱지 중 하나를 낸다. 딱지에는 별(★), 동그라미(●), 네모(■), 세모(▲), 네 가지 모양 중 하나 이상의 모양이 표시되어 있다. 두 어린이가 낸 딱지 중 어느 쪽이 더 강력한 것인지는 다음 규칙을 따른다.

만약 두 딱지의 별의 개수가 다르다면, 별이 많은 쪽의 딱지가 이긴다.
별의 개수가 같고 동그라미의 개수가 다르다면, 동그라미가 많은 쪽의 딱지가 이긴다.
별, 동그라미의 개수가 각각 같고 네모의 개수가 다르다면, 네모가 많은 쪽의 딱지가 이긴다.
별, 동그라미, 네모의 개수가 각각 같고 세모의 개수가 다르다면, 세모가 많은 쪽의 딱지가 이긴다.
별, 동그라미, 네모, 세모의 개수가 각각 모두 같다면 무승부이다.

라운드의 수 N과 두 어린이가 순서대로 내는 딱지의 정보가 주어졌을 때, 각 라운드별로 딱지놀이의 결과를 구하는 프로그램을 작성하시오.

입력 : 표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 딱지놀이의 총 라운드 수를 나타내는 자연수 N이 주어진다. N 은 1 이상 1,000 이하이다. 다음 줄에는 라운드 1에서 어린이 A가 내는 딱지에 나온 그림의 총 개수 a가 주어진다. a는 1 이상 100 이하이다. 뒤따라 나오는 a개의 정수는 어린이 A가 낸 딱지의 그림을 나타내는데, 각각 4, 3, 2, 1 중 하나의 값이다. 4, 3, 2, 1의 순서대로 주어지지 않을 수 있음에 주의하라. 다음 줄에는 라운드 1에서 어린이 B가 내는 딱지에 나온 그림의 총 개수 b가 주어진다. b도 1 이상 100 이하이다. 뒤따라 나오는 b개의 정수는 어린이 B가 낸 딱지의 그림을 나타내는데, 역시 4, 3, 2, 1 중 하나의 값이다. 역시 4, 3, 2, 1의 순서대로 주어지지 않을 수 있음에 주의하라. 다음 두 줄에는 라운드 2에서 어린이 A, B가 낸 딱지의 그림들을 같은 식으로 표현한다. 위와 같은 식으로 매 라운드마다 두 어린이가 낸 딱지의 정보는 두 줄에 표현되며, N 라운드의 딱지 정보는 차례대로 총 2N 개의 줄에 주어진다.

출력 : 표준 출력으로 총 N 줄을 출력한다. 출력의 i번째 (1 ≤ i ≤ N) 줄에 정확히 한 글자를 출력하는데, 출력하는 글자는 A, B, D 중 하나로 라운드 i의 결과를 나타낸다. 각 라운드의 결과는 A가 승자라면 A, B가 승자라면 B, 무승부라면 D이다.

*내 제출*
```python
n = int(input())

for i in range(n):
    a_list = [0] * 5
    b_list = [0] * 5
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    for v in range(1, len(a)): # a에 해당하는 숫자에 1 count
        a_list[a[v]] += 1
    for w in range(1, len(b)): # b에 해당하는 숫자에 1 count
        b_list[b[w]] += 1

    # 우선순위가 높은 뒤에서부터 확인해서 더 큰수가 있다면 큰수가 있는 사람을 출력 후 break
    for v in range(4,0,-1):
        if a_list[v] > b_list[v]:
            print('A')
            break
        elif a_list[v] < b_list[v]:
            print('B')
            break
        else:
            if v == 1:
                print('D')
                break
```

---

### 2563번_색종이

문제 : 가로, 세로의 크기가 각각 100인 정사각형 모양의 흰색 도화지가 있다. 이 도화지 위에 가로, 세로의 크기가 각각 10인 정사각형 모양의 검은색 색종이를 색종이의 변과 도화지의 변이 평행하도록 붙인다. 이러한 방식으로 색종이를 한 장 또는 여러 장 붙인 후 색종이가 붙은 검은 영역의 넓이를 구하는 프로그램을 작성하시오.

입력 : 첫째 줄에 색종이의 수가 주어진다. 이어 둘째 줄부터 한 줄에 하나씩 색종이를 붙인 위치가 주어진다. 색종이를 붙인 위치는 두 개의 자연수로 주어지는데 첫 번째 자연수는 색종이의 왼쪽 변과 도화지의 왼쪽 변 사이의 거리이고, 두 번째 자연수는 색종이의 아래쪽 변과 도화지의 아래쪽 변 사이의 거리이다. 색종이의 수는 100 이하이며, 색종이가 도화지 밖으로 나가는 경우는 없다

출력 : 첫째 줄에 색종이가 붙은 검은 영역의 넓이를 출력한다.

*내 제출*
```python
n = int(input())
arr = [[0]*100 for _ in range(100)] # 100*100인 정사각형
for i in range(n):
    a, b = map(int, input().split())
    for v in range(a, a+10): # 기준점부터 기준점+10까지
        for w in range(b, b+10): # 기준점부터 기준점+10까지
            arr[v][w] = 1

result = 0
for i in range(100):
    for j in range(100):
        if arr[i][j] == 1: # 1인부분이 있으면 result에 +1
            result += 1
print(result)
```

---

### 2628번_종이자르기

문제 : 가로 점선은 위에서 아래로 1번부터 차례로 번호가 붙어 있고, 세로 점선은 왼쪽에서 오른쪽으로 번호가 붙어 있다. 점선을 따라 이 종이를 칼로 자르려고 한다. 가로 점선을 따라 자르는 경우는 종이의 왼쪽 끝에서 오른쪽 끝까지, 세로 점선인 경우는 위쪽 끝에서 아래쪽 끝까지 한 번에 자른다. 예를 들어, <그림 1>의 가로 길이 10㎝이고 세로 길이 8㎝인 종이를 3번 가로 점선, 4번 세로 점선, 그리고 2번 가로 점선을 따라 자르면 <그림 2>와 같이 여러 개의 종이 조각으로 나뉘게 된다. 이때 가장 큰 종이 조각의 넓이는 30㎠이다. 입력으로 종이의 가로 세로 길이, 그리고 잘라야할 점선들이 주어질 때, 가장 큰 종이 조각의 넓이가 몇 ㎠인지를 구하는 프로그램을 작성하시오.

입력 : 첫줄에는 종이의 가로와 세로의 길이가 차례로 자연수로 주어진다. 가로와 세로의 길이는 최대 100㎝이다. 둘째 줄에는 칼로 잘라야하는 점선의 개수가 주어진다. 셋째 줄부터 마지막 줄까지 한 줄에 점선이 하나씩 아래와 같은 방법으로 입력된다. 가로로 자르는 점선은 0과 점선 번호가 차례로 주어지고, 세로로 자르는 점선은 1과 점선 번호가 주어진다. 입력되는 두 숫자 사이에는 빈 칸이 하나씩 있다.

출력 : 첫째 줄에 가장 큰 종이 조각의 넓이를 출력한다. 단, 넓이의 단위는 출력하지 않는다.

*내 제출*
```python
n, m = map(int,input().split()) # n : 종이의 가로의 길이, m : 종이의 세로의 길이
k = int(input()) # 자르는 횟수
cut_1 = [0]*k # 가로로 자르는 점선의 숫자 저장
cut_2 = [0]*k # 세로로 자르는 점선의 숫자 저장

for i in range(k):
    a, b = map(int,input().split()) # a = 0 이면 가로, a = 1이면 세로
    if a == 0:
        cut_1[i] = b
    else:
        cut_2[i] = b

# 오름차순 정렬
for i in range(k):
    for j in range(k):
        if cut_1[i] < cut_1[j]:
            cut_1[i], cut_1[j] = cut_1[j], cut_1[i]
        if cut_2[i] < cut_2[j]:
            cut_2[i], cut_2[j] = cut_2[j], cut_2[i]


result_1 = [0]*(k+1) # 가로로 잘랐을때 나오는 크기들을 저장할 리스트
result_2 = [0]*(k+1) # 세로로 잘랐을때 나오는 크기들을 저장할 리스트
cut_1[0], cut_2[0] = 0, 0

# result_1, result_2에 잘랐을때 나오는 값들을 저장
for i in range(1, k):
    result_1[i] = cut_1[i]-cut_1[i-1]
    result_2[i] = cut_2[i]-cut_2[i-1]
    if i == k-1:
        result_1[i+1], result_2[i+1] = m-cut_1[i], n-cut_2[i]

# 나올수있는 값들을 모두 연산하여 가장 클때의 값을 구한다
max_result = 0
for i in range(k+1):
    for j in range(k+1):
        if result_1[i] * result_2[j] > max_result:
            max_result = result_1[i] * result_2[j]

# k의 크기가 1일때는 result리스트를 구할때 반복문을 들어갈수 없어 따로 계산
if k == 1:
    if a == 0:
        max_result = (m-b)*n
    else:
        max_result = m*(n-b)
print(max_result)
```

---

### 2578번_빙고

문제 : 철수는 친구들과 빙고 게임을 하고 있다. 철수가 빙고판에 쓴 수들과 사회자가 부르는 수의 순서가 주어질 때, 사회자가 몇 번째 수를 부른 후 철수가 "빙고"를 외치게 되는지를 출력하는 프로그램을 작성하시오.

입력 : 첫째 줄부터 다섯째 줄까지 빙고판에 쓰여진 수가 가장 위 가로줄부터 차례대로 한 줄에 다섯 개씩 빈 칸을 사이에 두고 주어진다. 여섯째 줄부터 열째 줄까지 사회자가 부르는 수가 차례대로 한 줄에 다섯 개씩 빈 칸을 사이에 두고 주어진다. 빙고판에 쓰여진 수와 사회자가 부르는 수는 각각 1부터 25까지의 수가 한 번씩 사용된다.

출력 : 첫째 줄에 사회자가 몇 번째 수를 부른 후 철수가 "빙고"를 외치게 되는지 출력한다.

*내 제출*
```python
arr = [list(map(int, input().split())) for _ in range(5)] # 체크할 빙고
check = [list(map(int, input().split())) for _ in range(5)] # 사회자가 불러주는 번호

result = 0
for i in range(5):
    for j in range(5):
        result += 1 # 한번 불러줄때마다 result를 1 증가
        for v in range(5):
            for w in range(5):
                # check의 첫번째부터 순회하면서 arr에 있는 같은 숫자를 0으로 바꾼다
                if check[i][j] == arr[v][w]:
                    arr[v][w] = 0
                    break
        # 빙고 3개가 될수있는 최소횟수인 12번째부터 검증을한다
        if result >= 12:
            check_temp = 0
            temp_1 = 0 # 대각선
            temp_2 = 0 # 반대 대각선
            for n in range(5):
                temp_x = 0 # 가로
                temp_y = 0 # 세로
                for m in range(5):
                    # 가로
                    if arr[n][m] == 0:
                        temp_x += 1
                    if temp_x == 5:
                        check_temp += 1
                    # 세로
                    if arr[m][n] == 0:
                        temp_y += 1
                    if temp_y == 5:
                        check_temp += 1
                # 대각선
                if arr[n][n] == 0:
                    temp_1 += 1
                if temp_1 == 5:
                    check_temp += 1
                # 반대 대각선
                if arr[n][4-n] == 0:
                    temp_2 += 1
                if temp_2 == 5:
                    check_temp += 1
            if check_temp >= 3:
                print(result)
                result = -99
                break
```

---

### 2477번_참외밭

문제 : 예를 들어 참외밭이 위 그림과 같은 모양이라고 하자. 그림에서 오른쪽은 동쪽, 왼쪽은 서쪽, 아래쪽은 남쪽, 위쪽은 북쪽이다. 이 그림의 왼쪽위 꼭짓점에서 출발하여, 반시계방향으로 남쪽으로 30m, 동쪽으로 60m, 남쪽으로 20m, 동쪽으로 100m, 북쪽으로 50m, 서쪽으로 160m 이동하면 다시 출발점으로 되돌아가게 된다.

위 그림의 참외밭  면적은 6800m2이다. 만약 1m2의 넓이에 자라는 참외의 개수가 7이라면, 이 밭에서 자라는 참외의 개수는 47600으로 계산된다.

1m2의 넓이에 자라는 참외의 개수와, 참외밭을 이루는 육각형의 임의의 한 꼭짓점에서 출발하여 반시계방향으로 둘레를 돌면서 지나는 변의 방향과 길이가 순서대로 주어진다. 이 참외밭에서 자라는 참외의 수를 구하는 프로그램을 작성하시오.

입력 : 첫 번째 줄에 1m2의 넓이에 자라는 참외의 개수를 나타내는 양의 정수 K (1 ≤ K ≤ 20)가 주어진다. 참외밭을 나타내는 육각형의 임의의 한 꼭짓점에서 출발하여 반시계방향으로 둘레를 돌면서 지나는 변의 방향과 길이 (1 이상 500 이하의 정수) 가 둘째 줄부터 일곱 번째 줄까지 한 줄에 하나씩 순서대로 주어진다. 변의 방향에서 동쪽은 1, 서쪽은 2, 남쪽은 3, 북쪽은 4로 나타낸다.

출력 : 첫째 줄에 입력으로 주어진 밭에서 자라는 참외의 수를 출력한다.

*내 제출*
```python
k = int(input())
answer = [0]*6
for i in range(6):
    answer[i] = list(map(int, input().split()))

max_num, second_num = 0, 0 # 가로의 최대 길이, 세로의 최대길이
max_index, second_index = 0, 0 # 가로 최대길이의 인덱스값, 세로 최대길이의 인덱스값
for i in range(6):
    if answer[i][0] == 1 or answer[i][0] == 2: # 같은방향끼리 구해준다
        if max_num < answer[i][1]:
            max_num = answer[i][1]
            max_index = i
    if answer[i][0] == 3 or answer[i][0] == 4:
        if second_num < answer[i][1]:
            second_num = answer[i][1]
            second_index = i

# 가장 큰 가로와 세로 길이를 이용해 큰 사각형의 넓이를 구하고
# 비어있는 사각형의 넓이를 뺄것이다
# 비어있는 삼각형의 길이는 큰 인덱스와 인접해있지 않기때문에
# 인접한 인덱스의 좌우값을 new_list라는 새로운 리스트에 담아준다
new_list = [answer[(max_index+5)%6],answer[(max_index+1)%6],answer[(second_index+5)%6],answer[(second_index+1)%6]]

# 만약 new_list에 없는 값이라면 작은 사각형을 이루는 값이다
minus = 1
for i in answer:
    if i not in new_list:
        minus *= i[1]

# 결과값 출력
result = (max_num*second_num) - minus
print(result*k)
```