# SWEA 알고리즘 문제
## 4831. 전기버스(D3)

### 문제

: A도시는 전기버스를 운행하려고 한다. 전기버스는 한번 충전으로 이동할 수 있는 정류장 수가 정해져 있어서, 중간에 충전기가 설치된 정류장을 만들기로 했다.

버스는 0번에서 출발해 종점인 N번 정류장까지 이동하고, 한번 충전으로 최대한 이동할 수 있는 정류장 수 K가 정해져 있다.

충전기가 설치된 M개의 정류장 번호가 주어질 때, 최소한 몇 번의 충전을 해야 종점에 도착할 수 있는지 출력하는 프로그램을 만드시오.

만약 충전기 설치가 잘못되어 종점에 도착할 수 없는 경우는 0을 출력한다. 출발지에는 항상 충전기가 설치되어 있지만 충전횟수에는 포함하지 않는다.

### 입력

: 첫 줄에 노선 수 T가 주어진다.  ( 1 ≤ T ≤ 50 )
각 노선별로 K, N, M이 주어지고, 다음줄에 M개의 정류장 번호가 주어진다. ( 1 ≤ K, N, M ≤ 100 )


### 출력

: #과 노선번호, 빈칸에 이어 최소 충전횟수 또는 0을 출력한다.

*내 제출*

```python
T = int(input())

for tc in range(1,T+1):
    K,N,M = map(int,input().split())
    # K : 한번 충전으로 최대 이동할수 있는 정류장 수
    # N : 전체 가야하는 거리
    # M : 충전기가 설치된 정류장의 수
    cha = list(map(int,input().split()))
    # cha : 충전기가 설치된 정류장 번호
    result = 0
    # result : 현재 위치를 나타내는 변수
    answer = 0
    # answer : 충전소를 최소로 가는 횟수
    
    while M>0: 
        for j in range(len(cha)-1,-1,-1):
            if cha[j] <= result+K:
                # 충전기가 설치된 정류장을 뒤에서부터 보면서 충전소를 최대한 늦게 들릴때를 적용
                if cha[j] == result:
                    print(f'#{cnt} 0')
                    M = 0
                    break
                # 만약 전에 나왔던 충전소를 또 들리게된다면 한번 충전으로 갈수있는 최대의 거리로 다음 충전소를 갈수 없기때문에 0을 출력하고 반복문 탈출
                result = cha[j]
                # result에 현재 정류장위치를 저장
                answer += 1
                # 충전소를 들리면 answer값을 1증가
                if result+K >= N:
                    print(f'#{tc} {answer}')
                    M = 0
                    break
                # 남은 충전량으로 총 거리인 N을 갈수있다면 더이상 충전소를 들리지 않아도 되기때문에 answer값을 출력하고 break
                break
```
---

## 4835. 구간합(D2)

### 문제

: N개의 정수가 들어있는 배열에서 이웃한 M개의 합을 계산하는 것은 디지털 필터링의 기초연산이다.

M개의 합이 가장 큰 경우와 가장 작은 경우의 차이를 출력하는 프로그램을 작성하시오.

다음은 N=5, M=3이고 5개의 숫자 1 2 3 4 5가 배열 v에 들어있는 경우이다.

이웃한 M개의 합이 가장 작은 경우 1 + 2 + 3 = 6

이웃한 M개의 합이 가장 큰 경우 3 + 4 + 5 = 12
 

답은 12와 6의 차인 6을 출력한다.

### 입력

: 첫 줄에 테스트 케이스 개수 T가 주어진다.  ( 1 ≤ T ≤ 50 )

다음 줄부터 테스트케이스의 첫 줄에 정수의 개수 N과 구간의 개수 M 주어진다. ( 10 ≤ N ≤ 100,  2 ≤ M ＜ N )

다음 줄에 N개의 정수 ai가 주어진다. ( 1 ≤ a ≤ 10000 )


### 출력

: 각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 답을 출력한다.

*내 제출*

```python
T = int(input())

for tc in range(1,T+1):
    N,M = map(int,input().split())
    num_list = list(map(int,input().split()))
    
    min_num, max_num = 1000000000, 0 # 최소값과, 최댓값을 범위바깥의 범위로 지정
    for i in range(N-M+1):
        temp = 0
        for j in range(i,i+M):
            # 예를들어 N이 10, M이 3이라면 1번 인덱스부터 8번 인덱스까지만 순회하도록 범위를 지정
            temp += num_list[j]
            # temp변수에 원하는 값을 값을 저장
        if temp < min_num:
            min_num = temp
            # 더 작으면 min_num에 저장
        if temp > max_num:
            max_num = temp
            # 더 크면 max_num에 저장
    print(f'#{tc} {max_num-min_num}')
```
---
## 4835. Flatten(D3)

### 문제

: 한 쪽 벽면에 다음과 같이 노란색 상자들이 쌓여 있다.

높은 곳의 상자를 낮은 곳에 옮기는 방식으로 최고점과 최저점의 간격을 줄이는 작업을 평탄화라고 한다.

평탄화를 모두 수행하고 나면, 가장 높은 곳과 가장 낮은 곳의 차이가 최대 1 이내가 된다.

평탄화 작업을 위해서 상자를 옮기는 작업 횟수에 제한이 걸려있을 때, 제한된 횟수만큼 옮기는 작업을 한 후 최고점과 최저점의 차이를 반환하는 프로그램을 작성하시오.

가장 높은 곳에 있는 상자를 가장 낮은 곳으로 옮기는 작업을 덤프라고 정의한다.

위의 예시에서 제1회 덤프를 수행한 이후 화면은 다음과 같다.

A부분의 상자를 가장 낮은 B부분에 덤프하였으며, A대신 A’부분의 상자를 사용해도 무방하다.

다음은 제2회 덤프를 수행한 이후의 화면이다.

A’부분의 상자를 옮겨서, C부분에 덤프하였다. 이때 C 대신 C’부분에 덤프해도 무방하다.

2회의 덤프 후, 최고점과 최저점의 차이는 8 – 2 = 6 이 되었다 (최초덤프 이전에는 9 – 1 = 8 이었다).

덤프 횟수가 2회로 제한된다면, 이 예시 문제의 정답은 6이 된다.

### 입력

: 총 10개의 테스트 케이스가 주어지며, 각 테스트 케이스의 첫 번째 줄에는 덤프 횟수가 주어진다. 그리고 다음 줄에 각 상자의 높이값이 주어진다.


### 출력

: #부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 테스트 케이스의 최고점과 최저점의 높이 차를 출력한다.

*내 제출*

```python
for tc in range(1,11):
    T = int(input())
    num_list = list(map(int,input().split())) 
    # num_list에 상자 담기
    
    while T > 0: # 주어진 덤프의 범위가 0보다 작아질때까지 반복 
        min_num,max_num = 101,0
        # num의 최소, 최대의 바깥 범위로 값을 대입시켜준다.
        for i in range(100): # 문제에서 가로의 길이가 100으로 지정
            if num_list[i] > max_num:
                max_num = num_list[i]
                max_index = i
                # 가장 클때의 값을 저장하고, 인덱스번호도 저장
            if num_list[i] < min_num:
                min_num = num_list[i]
                min_index = i
                # 가장 작을때의 값을 저장하고, 인덱스번호도 저장
        num_list[max_index] -= 1 # 큰값에서 1을 빼준다
        num_list[min_index] += 1 # 작은값에서 1을 더해준다
        T -= 1 # 덤프의 범위에서 1을 빼준다

    min_answer, max_answer =100,0
    for i in range(100):
        if num_list[i] > max_answer:
            max_answer = num_list[i]
        if num_list[i] < min_answer:
            min_answer = num_list[i]
        # 덤프가 완료된 후에 num_list에서 최대값-최소값을 구하기위해 최대값, 최소값을 구해준다.

    print(f'#{tc} {max_answer-min_answer}')
```